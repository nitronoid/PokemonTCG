UML -> add things to enumeration TYPE

code -> Ability.h :> change _newAbility to _ability as per UML (constructor parameter)
UML -> Ability :> add second default constructor from Ability.h
UML -> Ability :> add operator from Ability.h
UML -> Ability :> add const at the end of use(...) function

UML -> Card :> m_ID should be const unsigned
code -> Card.h :> change m_ID variable type from const int to const unsigned as per UML
UML -> Card :> protected constructor with param int :> change type to Card&
	or in code -> Card.h :> change first constructor or add a new one
UML -> Card :> add protected constructor with _id, _name and _ability
UML -> Card :> add "const Game &_game" to activateAbility params

UML -> TrainerCard :> add default constructor as per code
UML -> TrainerCard :> add const Abilily _ability to params
UML -> TrainerCard :> (maybe unnecessary) add virtual override of clone()

UML -> EnergyCard :> add deafult constructor as per code
UML -> EnergyCard :> add const std::string &_name, const Ability _ability
UML -> EnergyCard :> (maybe unnecessary) add virtual override of clone()

UML -> PokemonCard :> add default constructor as per code
UML -> PokemonCard :> add operator as per code
UML -> PokemonCard :> m_type, m_resistance and m_weakness should be const
UML -> PokemonCard :> remove "m_retreat : int" (duplicate and not matching code version)
UML -> PokemonCard :> change m_stage type to const unsigned
code -> Pokemoncard.h :> change m_attackCost to m_attackRequirements as per UML
UML -> PokemonCard :> change _id type to const unsigned (constructor param)
code -> PokemonCard.h :> change _id type to const unsigned

UML -> BoardSlot :> m_pokemon should be std::unique_ptr<PokemonCard>
UML -> BoardSlot :> m_energy should be std::vector<std::unique_ptr<EnergyCard>>
UML -> BoardSlot :> m_tool should be  std::unique_ptr<TrainerCard>
UML -> BoardSlot :> m_basePokemons should be std::vector<std::unique_ptr<PokemonCard>>
UML -> BoardSLot :> _card param in attachCard func should be std::unique_ptr<PokemonCard> &&
UML -> BoardSLot :> detachPokemon(), detachTool() and detachEnergy() should be of type std::unique_ptr<...>
UML -> BoardSLot :> detachEnergy should take param (const unsigned _index)
UML -> BoardSLot :> setPokemon _pokemon param should be of type std::unique_ptr<PokemonCard> &&
UML -> BoardSLot :> add a public function :> const std::unique_ptr<PokemonCard>& pokemon() const;
UML -> BoardSLot :> add a public function :> const std::vector<std::unique_ptr<EnergyCard>>& energy() const;

UML -> CardPile :> virtual void put should take param (std::unique_ptr<Card> &&_card)
UML -> CardPile :> virtual func take() should be of type std::unique_ptr<Card>

UML -> Bench :> add constructor as per code
UML -> Bench :> add operator as per code
UML -> Bench :> remove cardAt function from UML
UML -> Bench :> add public function   BoardSlot& slotAt(const unsigned _index);
UML -> Bench :> add public  function override   virtual void put(std::unique_ptr<Card> &&_card) override;
UML -> Bench :> add public  function override   virtual std::unique_ptr<Card> take(const unsigned _index) override;
UML -> Bench :> add public  function    unsigned numBenched() const;

UML -> PrizeCards :> add constructor as per code
UML -> PrizeCards :> add operator as per code
UML -> PrizeCards :> remove peek function from UML
UML -> PrizeCards :> change m_cards type to std::array<std::unique_ptr<Card>, 6>
UML -> PrizeCards :> add public  function override    virtual void put(std::unique_ptr<Card> &&) override;
UML -> PrizeCards :> add public  function override    virtual std::unique_ptr<Card> take(const unsigned _index) override;
UML -> PrizeCards :> add public  function    const std::array<std::unique_ptr<Card>, 6> &view();

UML -> Hand :> add constructor as per code
UML -> Hand :> add operator as per code
UML -> Hand :> change m_cards type to std::vector<std::unique_ptr<Card>>
UML -> Hand :> add add public  function override    virtual void put(std::unique_ptr<Card> &&_card) override;
UML -> Hand :> add add public  function override    virtual std::unique_ptr<Card> take(const unsigned _index) override;
UML -> Hand :> change view() funstion def to    const std::vector<std::unique_ptr<Card>>& view();

UML -> Deck :> add constructor as per code
UML -> Deck :> add operator as per code
UML -> Deck :> change m_cards type to std::vector<std::unique_ptr<Card>>
UML -> Deck :> add add public  function override    virtual void put(std::unique_ptr<Card> &&_card) override;
UML -> Deck :> add add public  function override    virtual std::unique_ptr<Card> take(const unsigned _index) override;
UML -> Deck :> change view() funstion def to    const std::vector<std::unique_ptr<Card>>& view();

UML -> DiscardPile :> add constructor as per code
UML -> DiscardPile :> add operator as per code
UML -> DiscardPile :> change m_cards type to std::vector<std::unique_ptr<Card>>
UML -> DiscardPile :> add add public  function override    virtual void put(std::unique_ptr<Card> &&_card) override;
UML -> DiscardPile :> add add public  function override    virtual std::unique_ptr<Card> take(const unsigned _index) override;
UML -> DiscardPile :> change view() funstion def to    const std::vector<std::unique_ptr<Card>>& view();
UML -> Deck :> add add public  function void shuffle();

UML -> Player :> M_active should be m_activePokemon
UML -> Player :> change constructor type to public
UML -> Player :> add default constructor as per code
UML -> Player :> add const at hte end of endTurn(), getDummyGame(), viewHand() and viewBench()
UML -> Player :> chooseCard :> change func return type to std::vector<std::unique_ptr<Card>>
UML -> Player :> chooseCard :> _options param should be of type std::vector<std::unique_ptr<Card>> &
UML -> Player :> attack :> change param to   const std::string &_name

code -> implement AIPlayer.h and .cpp

UML -> HumanPlayer :> add default constructor as per code
code -> HumanPlayer.h :> fix constructors taking HumanPlayer instead of Game
UML -> HumanPlayer :> add const at the end of clone() func
UML -> HumanPlayer :> chooseCard should be of type std::vector<std::unique_ptr<Card>>
UML -> HumanPlayer :> chooseCard :> _ammount should be of type const unsigned
UML -> HumanPlayer :> chooseCard :> _options should be of type std::vector<std::unique_ptr<Card>>

UML -> Game :> remove m_playerOne and m)playerTwo and replace with std::array<std::unique_ptr<Player>, 2> m_players;
UML -> Game :> remove m_currentPlayer
UML -> Game :> m_turn should be m_turnCount
	or Game.h -> m_turnCount should be m_turn
UML -> Game :> m_canPlay should be m_playableCards
UML -> Game :> add bool m_turnFinished;
UML -> Game :> add constructor as per code
UML -> Game :> add const at the end of clone() func
UML -> Game :> mismatched functions (attack(UML) -> dealDamage(in code) ,  canPlay and onPlay (UML) -> play(in code))

